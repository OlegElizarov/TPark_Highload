# TPark_Highload

Курсовой проект
=================

В данном проекте будет рассмотрен почтовый сервис, который позволяет клиентам 
читать и отправлять письма, также имеется возможность отправки с различными вложенными файлами.


Часть 1. Определение возможного диапазона нагрузок
=================

Согласно [wikipedia](https://ru.wikipedia.org/wiki/Население_России) население России к 2020 году можно принять равным 
146млн человек.
А согласно [yandex.radar](https://radar.yandex.ru/yandex?month=2020-08) среднее количество уникальных пользователей 
Яндекс почты составляет примерно 17млн человек в месяц , что составляет 11% от населения России.
Согласно [similarweb](https://www.similarweb.com/website/mail.yandex.ru/) у почты Яндекса общее количество посещений в 
месяц примерно 400млн(У почты Mail.ru - более 540млн), со средним временем нахождения пользователя на сайте - 8 минут.
Общее количество активных аккаунтов почты mail.ru составляет [100млн](https://corp.mail.ru/ru/company/portal/)

Возможности пользователя, которые ему предоставляет почта:
* Регистрация
* Авторизация
* Постраничное получение списка последних писем
* Отправка и пересылка писем(Есть возможность прикреплять файлы до  25Мб [(Почта Яндекса)](https://yandex.ru/support/mail/web/letter/attachments.html) )
* Удаление писем
* Чтение писем
* Скачивание вложений из писем


Учитывая дневную аудиторию Яндекс почты в [6.2 млн человек](https://radar.yandex.ru/yandex?month=2020-08), каждый из которых остается на сайте 
примерно 8(мы возьмем 5 для усреднения) минут, то ,можно провести эксперимент, предложив среднестатистическому 
пользователю провести на сайте почты это самое время.Используя вкладку network браузера , 
можно получить количество различных запросов, которые сгенерировал пользователь за это время равное - 500 штук.
```
RPS(общий) = (6.2*10^6 * 500)/(24*60*60) ~ 36000 
```

Часть 2. Выбор планируемой нагрузки
=================
Основываясь на цифрах из пункта 1, выберем целевые цифры для нашего проекта равными:
* 5 млн уникальных пользователей в день
* 80 млн активных аккаунтов (54% населения России, 80%)
* Поддержка RPS = 30000 запросов в секунду

Часть 3. Логическая схема базы данных
=================
![](images/LogDB.png)

Часть 4. Физическая системы хранения
=================

Таблица пользователя в базе данных:

| id  | имя | фамилия | дата рождения | пол | имя аккаунта | пароль(хэш) | телефон |
|-----|-----|-----------|---------|-----------------|------------------|------------------|----|
|bigint|varchar(20)|varchar(40)|timestamp:date|boolean|varchar(80)|varchar(32)|varchar(11)|

Максимальный вес одного пользователя - 196 байт ~ 0,2KB

Таблица сообщения в базе данных:

| id  | id отправителя | id получателя | тема | текст | дата отправки | прочитано |id папки|id ответа|список ссылок на файлы|
|-----|-----|-----------|---------|-----------------|------------------|------------------|----|------|-------|
|bigint|bigint|bigint array[5]|varchar(50)|varchar(12000)|timestamp|boolean|bigint|bigint|varchar(200)|

Максимальный вес одного письма - 12331 байт ~ 12KB

Таблица папок в базе данных:

| id  | id пользователя | название | количество писем | паттерн добавления - тема | паттерн добавления - автор | паттерн добавления - текст |
|-----|-----|-----------|---------|-----------------|------------------|------------------|
|bigint|bigint|varchar(20)|bigint|varchar(50)|varchar(80)|varchar(100)|

Максимальный вес одной папки - 274 байт ~ 0,3KB


Рассмотрим разные нагрузки от различных типов запроса:<br>
**1)** Получения списка последних писем (50 штук) - согласно исследованию, данный 
запрос будет весить примерно 23kb данных,без учета иконок почт отправителей( [1](images/message_list_proof.png) и [2](images/message_list_size.png )).Предположим, что 
при нашей дневной нагрузке в 5млн уникальных пользователей, каждый из них запросит список 
писем 2 раза.Получаем:
```
Передаваемый трафик в секунду: 5 000 000 * 2 * 23kb / 24 * 60 * 60 ~ 2660kb (возьмем 3MB для запаса)  
```

В качестве СУБД будет использоваться [LevelDB](https://github.com/google/leveldb).
Для каждого пользователя на сервере с СУБД будет создана папка, в которой будут храниться все связанные с 
ним сущности.Это позволит получать сообщения пользователя, конкретно из его стораджа, а не из какой-то общей таблицы,
в которой будет миллионы сообщений, что очень замедлит поиск.Еще стоит отметить, что чаще всего мы хотим 
получать последовательный список сообщений, так что данная система хранения будет способствовать последовательному 
чтению с диска.<br>
Если принять конфигурацию сервера равной конфигурации из официального репозитория [LevelDB](https://github.com/google/leveldb#setup)
и предположить, что деградация производительности происходит линейно от величины файла с данными,то можно подсчитать
все необходимые данные.
При размере файла базы в 110MB она обеспечивает при последовательном чтении 
[2 081 000 чтений в секунду(261MB/s)](https://github.com/google/leveldb#read-performance).
При размере базы в 1GB примем скорость последовательного чтения равной 20MB/s.
Получается, что для обработки получения списка писем хватит мощности одного сервера.<br>
**2)** Чтение одного письма - согласно исследованию, средний вес одного письма - 12KB без учета прикрепляемого файла.
([3](images/single_message_proof.png) и [4](images/single_message_size.png) )
Примем, что пользователь читает хотя бы 5 писем в день.
Тогда получим:
```
Передаваемый трафик в секунду: 5 000 000 * 5 * 12kb / 24 * 60 * 60 ~ 3472KB (возьмем 4MB для запаса) 
```
Для данной задачи мощности все того же одного сервера с LevelDB вполне достаточно.<br>
**3)** Написание письма - по цифрам не сильно отличается от чтения,так как существует много ботов, 
которые увеличивают среднее количество написанных писем на человека. Примем скорость последовательной записи 
в конец файла - [10MB/s](https://github.com/google/leveldb#write-performance) при большом размере нашей базы.


Основной проблемой в данной ситуации будет огромный объем базы данных, что вынудит нас 
использовать шардирование по uid. То есть на одном физическом сервере с базой данных будут храниться те строки в таблицах,
которые относятся к диапазону юзеров,размещенных на этой машине.
В LevelDB нет удобной возможности шардинга в комплекте,поэтому стоит использовать хранилища типа ключ-значение, 
где ключ - uid пользователя, а значение - указание на конкретный сервер с данными.Возможно, что для экономии стоит 
объединить эту задачу с хранением кук и получить ключ - user_cookie , а значение - id и его сервер.
Для подобных задач отлично подходит Redis. 

<br>Хранить файлы, которые прикрепляются к сообщениям является не самой выигрышной стратегией.Их можно вынести в 
отдельное хранилище, такое как Amazon S3,а в LevelDB будем хранить ссылки на эти файлы.

Часть 5. Выбор технологического стека проекта(кроме СУБД)
=================

**Бэкенд:** Главным языком для серверной разработки будет выбран Golang, который позволяет быстро и эффективно 
писать код.В его основе лежит теоретическая модель [CSP](https://en.wikipedia.org/wiki/Communicating_sequential_processes).

```
Scalling by adding more of the same

Golang UK Conference 2017 by Arne Claus
```

Она обеспечит хорошую масштабируемость Бэкенда, а также позволит избежать блокировок при конкурентном доступе. 
В основном код будет написан с использованием обширной стандартной библиотеки, роутером будет выбран 
[fasthttp](https://github.com/valyala/fasthttp), который показывает наилучшие показатели производительности.
Безусловно , нужно учитывать трудности со сборщиком мусора, который будет снижать производительность 
раз за какое-то  △t времени.Поэтому необходимо будет учитывать не только среднюю производительность , 
но и ее нижнюю границу.

**Фронтенд:** Выбор CSS,HTML,TypeScript/JavaScript , как технологий для фронтенд составляющей проекта будет
обусловлен их популярностью и изученностью годами.Для JavaScript существует уже огромное количество библиотек ,которые
как и упрощают верстку, так и способны влиять на производительность кода.TypeScript способен и ускорить
разработку из-за отлавливания ошибок при компиляции, и обезопасить наш будущий код от непредсказуемого поведения.

**Протоколы:** В данном проекте подразумевается использование https и http2 для связи клиента с бэкендом.Также будет
реализована связь с помощью websocket протокола, для отображения новых пришедших пользователю сообщений(как пример)
в режиме реального времени.
Связь микросервисов на бэкенде будет осуществляться классическим для Golang'а способом -  через GRPS+Protobuf, что
является одним из самых эффективных способов общения как с точки зрения скорости, так и с точки зрения размера 
передаваемого трафика.

Часть 6. Расчет нагрузки и потребного оборудования
=================
БД:<br>
В 4 пункте были рассмотрены многие цифры, касательно системы писем и пользователей.
Предположим, что у одного юзера в среднем 500 писем в ящике всего(отправленные и входящие во всех папках) и 6 папок.
Получаем
```
Общий объем для хранения писем = 80млн * 500 * 12KB ~ 447TB
```
```
Средний вес одного пользователя со всеми данными  = 
0,2KB(данные о пользователе) + (500 * 12KB)(пиьсма) + (6 * 0,3KB)(папки) = 6002KB ~ 6MB
```
Для хранения данных об одном пользователе нужно 6MB.

Выходит, что если мы закупим сервера вида:

| CPU(cores) | RAM(GB) | SSD(GB) |
|------------|---------|---------|
| 8         | 32      | 4096    |


то на один из них с учетом запаса под рост данных в 50% на нем уместится 2048GB/6MB ~ **350 000 пользователей**.
Всего таких серверов понадобится 80 000 000 / 350 000 = **229 штук**

Фронтенд:<br>

Объем фронтенд составляющей примерно 3MB.Тогда подсчитаем, что <br>
3 * 5 000 000(количество пользователей в день) = 15 000 000 MB/день = 173MB/s

Много физической памяти фронтенд серверу не особо надо,она будет потрачена в основном на кеширование запросов, 
а вот RAM ему понадобиться побольше.Возьмем:

| CPU(cores) | RAM(GB) | SSD(GB) |
|------------|---------|---------|
|   8       | 32      | 512    |

Балансировщик:<br>

В пункте 2 мы выбрали общую нагрузку в 30000RPS. Будем использовать nginx.Согласно [nginx_test](https://www.nginx.com/blog/testing-the-performance-of-nginx-and-nginx-plus-web-servers/)
при среднем объеме требуемого пользователю контента в 10MB , мы видим , что можем обойтись 16 ядрами и 32GB RAM.

| CPU(cores) | RAM(GB) | SSD(GB) |
|------------|---------|---------|
|   16       | 32      | 512    |

Бэкенд:<br>

Бэкенд должен соответствовать производительности БД, но благодаря микросервисной архитектуре мы 
грамотно разбиваем нагрузку. Согласно [5](images/img_requests.png) и [6](images/xhr_requests.png), мы видим
что большая часть запросов - получение картинок(50/50 статика- пользовательские) и вспомогательные запросы для 
клиентской стороны.Из суммарных 30000RPS на бэкенд приходится лишь примерно 5000, которые и распределяются по 
микросервисам. Если мы возьмем 5 микросервисов, 2 для авторизации и 3 для работы с сообщениями,то каждому из них 
будет достаточно следубщих параметров:

| CPU(cores) | RAM(GB) | SSD(GB) |
|------------|---------|---------|
|   8       | 16      | 256    |

Часть 7. Выбор хостинга/облачного провайдера и расположения серверов
=================

Часть 8. Схема балансировки нагрузки
=================

Выше уже говорилось, что будем использовать nginx для балансировки нагрузки на 7 уровне модели OSI(L7). 
Используем алгоритм Round Robin,который позволит равномерно распределить нагрузку.Так же отметим, что сам по себе 
nginx имеет инструменты для SSL. 

Часть 9. Обеспечение отказоустойчивости
=================

Для обеспечения устойчивости нашим многочисленным серверам БД необходимо поддерживать у них 
реплики.Сделать это только встроенным средствами LevelDB не выйдет.
Будет использовать Apache ZooKeeper для выбора ведущего устройства из 
набора узлов , настроенных для репликации хранилища LevelDB. Затем синхронизирует все 
подчиненные хранилища LevelDB с ведущим устройством(оригинал), обновляя их, подтягивая все обновления 
с ведущего устройства.Реплицированное хранилище LevelDB использует те же файлы данных, что 
и оригинальное хранилище LevelDB, поэтому мы можем переключать конфигурацию между реплицированным 
и нереплицированным в любое время.
